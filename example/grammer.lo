// base type
u8 i8 u16 i16 u32 i32 u64 i64 int uint
f32 f64
bool
str

// variable
a i32 = unsafe // uninitialize variable
a i32 = 1 // property type infer
a i32 = i32 1 // value copy
a i32 = 1 // error assign const int to int, Implicit variable cast initialization is not allowed

// auto variable
a := 1 // const i32
a := int 1 // i32
a := getData()

// array
a u32[] = {}
a u32[,] = {{}}

// array index and splice
b := a(1)
b := a(1,2)

// tuple tentative
a tup<u32, str> = (1, 2)

// pointer
a u32* // variable pointer
a u32[]* // array pointer
a u32*[] // pointer array

// function pointer
a ()* // with no params and no return function pointer 
a (u32)* // with params and no return function pointer
a (u32)*[] // with params and no return function pointer array
a (u32)*[]* // with params and no return function pointer array's pointer
a ()* u32 // with return and no params function pointer
a ()* ()* // with return and params function pointer's array, return type is ()*
a ()*[] u32 // with return and no params function pointer's array, return type is u32
a (u32, u32)*[] u32 // with return and params function pointer's array, return type is u32
a (u32)*[] (u32)*[] u32 // with return and params function pointer's array, return type is (u32)*[] u32
a (u32)* u32
a ([u32, u32]*[])*[] ([u32, u32]*[])* u32

// reference only to stack variable
// reference must set initialize value
a = ref b

t = if (a == 0) 1 else 2
t = if a == 0 { 1 } else { 2 }

for bool type { }
for iter type { }
for loop(0) { } // for (Iter i = Loop(10); bool(i); i.next()) {}
for range(0, 10) {}
for stride(0, 10, 2) {}
for a = range(array.begin, array.end) {} // for (Iter i = until(array.begin, array.end); bool(i); i.next()) {}